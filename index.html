<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Jkrvivian&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Jkrvivian&#39;s Blog">
<meta property="og:url" content="http://jkrvivian.github.io/index.html">
<meta property="og:site_name" content="Jkrvivian&#39;s Blog">
<meta property="og:locale">
<meta property="article:author" content="Vivian Lin">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Jkrvivian's Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Jkrvivian&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://jkrvivian.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-compiler-lexical-detail" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/04/03/compiler-lexical-detail/" class="article-date">
  <time class="dt-published" datetime="2018-04-03T08:05:51.000Z" itemprop="datePublished">2018-04-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/04/03/compiler-lexical-detail/">噢！我的編譯器 – Lexical Analysis Detail</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>大致上了解 lexical analyzer 做了什麼之後，我們可以再更進一步看細節：</p>
<ul>
     <li>字串怎麼讀？</li>
     <li>字串怎麼切？</li>
     <li>token class 怎麼定義？</li>
</ul>

<h4>字串怎麼讀？</h4>
當專案很大，程式碼很多時，讀取速度當然就愈慢 。因此，讀程式碼時就不是一個字元一個字元慢慢讀了，而是一次抓取多個字元放進緩存的 buffer 中。畢竟和 disk 拿取資料， 系統呼叫的成本是很高的呢！於是每次拿取的資料的單位就與 disk block 大小一致，如果檔案沒那麼大的話，就會在最後面加一個特殊的結尾字符，一般稱之為 eof (end of file)。

<p>所以當遇到 eof 時，就知道要更新 buffer，拿下一段的程式碼了。</p>
<h4>字串怎麼切？</h4>
有了 input stream 後，要切。但怎麼知道這一刀要下在哪裡？怎麼記住每一段的範圍呢？

<p>龍書中提到使用兩個標記標住起點與終點：lexemeBegin, forward。</p>
<p>想法很簡單：</p>
<p>由 forward 不斷前進，找到符合規則的 token 後就記錄下來，更新 lexemeBegin，然後再重複直到結束。</p>
<h4>token class 怎麼定義？</h4>
這個部份就是利用 lex 或 bison 實做 scanner 的重頭戲。如何訂一條規則，描述出這個 token 的 pattern 呢？

<p>這就需要 <strong><span style="color: #ff6600;">RE (regular expression)</span></strong> 出場了！所謂的 regular expression 其實就是透過定義一些符號試圖精簡的表示以個語句的規則，這個的應用場合非常廣泛，如在很多「搜尋」的場景都能夠使用 RE 過濾出目標。</p>
<p>詳細的 RE 語法可以參照 <a target="_blank" rel="noopener" href="https://atedev.wordpress.com/2007/11/23/%E6%AD%A3%E8%A6%8F%E8%A1%A8%E7%A4%BA%E5%BC%8F-regular-expression/">正規表達式 Regular Expression</a></p>
<p>在龍書中還提到了在建構 lexical analyzer 時，會先把 regular expression 轉換成<span style="color: #ff6600;"><strong>狀態轉移圖</strong></span>表示 <span style="color: #ff6600;"><strong>(transition diagram)</strong><span style="color: #000000;">，為的是能建構一連串的判斷動作，如圖：</span></span></p>
<figure>
    <img class="size-medium" src="https://cs.nyu.edu/~gottlieb/courses/2000s/2007-08-fall/compilers/lectures/diagrams/trans-dia-num.png" alt="unsigned number transition diagram" width="999" height="290" /> 
    <figcaption style="text-align:center">unsigned number transition diagram</figcaption>
</figure>

<p>每一個原圈代表一個狀態，當走到<strong>雙圈</strong>時就代表<strong>最終</strong>狀態且是被<strong>接受</strong>的！而每一條箭頭稱為 edge，代表在狀態 a 且遇到 edge 上的字元時前進到箭頭指向的狀態 b。例如：在 state13 時，遇到 E 即前進到 state16。</p>
<p>也就是說每一個 token 都會轉成不同的 transition diagram，我們便可以把這張圖轉換成以 switch case 的程式碼，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">TOKEN getRelop()                        &#x2F;&#x2F; TOKEN has two components</span><br><span class="line">    TOKEN retToken &#x3D; new(RELOP);          &#x2F;&#x2F; First component set here</span><br><span class="line">    while (true)</span><br><span class="line">       switch(state)</span><br><span class="line">         case 0: c &#x3D; nextChar();</span><br><span class="line">                 if (c &#x3D;&#x3D; &#39;&amp;lt;&#39;)      state &#x3D; 1;</span><br><span class="line">                 else if (c &#x3D;&#x3D; &#39;&#x3D;&#39;) state &#x3D; 5;</span><br><span class="line">                 else if (c &#x3D;&#x3D; &#39;&amp;gt;&#39;) state &#x3D; 6;</span><br><span class="line">                 else fail();</span><br><span class="line">                 break;</span><br><span class="line">         case 1: ...</span><br><span class="line">         ...</span><br><span class="line">         case 8: retract();  &#x2F;&#x2F; an accepting state with a star</span><br><span class="line">                 retToken.attribute &#x3D; GT;  &#x2F;&#x2F; second component</span><br><span class="line">                 return(retToken);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<h5>沒走到雙圈的最終狀態 == fail ?</h5>
這答案是<span style="color: #ff6600;"><strong>不夠全面</strong></span>的，沒有走到雙圈並不代表這個字串是有誤，而是他不屬於這一個 token class 的。

<p>因此會繼續以走下一個 token class 的 transition diagram，直到最終狀態。如果某個字串它能多個匹配不同 token class 的話，便會歸類給最先走成功的 token class。</p>
<p>真正的 fail 是在於當所有 transition diagram 都走完且沒有任一匹配的時候，這時候 lexer 就會直接噴錯囉！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jkrvivian.github.io/2018/04/03/compiler-lexical-detail/" data-id="cknczoq810003ql4w5rm79gc6" data-title="噢！我的編譯器 – Lexical Analysis Detail" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/compiler/" rel="tag">compiler</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-my-2-double" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/03/30/my-2-double/" class="article-date">
  <time class="dt-published" datetime="2018-03-30T03:25:49.000Z" itemprop="datePublished">2018-03-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/03/30/my-2-double/">代表我的兩個 Double</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>前些天嵌入式課程中的考題十分有趣，利用了 double 轉成有意義的字串。</p>
<p>這在某些應用場景十分有用，可以單純使用數值表示字串，甚至透過一些數值運算可以更改字串內容。</p>
<p>題目出處：<a target="_blank" rel="noopener" href="https://drive.google.com/open?id=19ceIq9crvvip_9cY8nNbL01l3ml2hXMR">week5 隨堂測驗(中)</a></p>
<p>以下是能夠印出我 ID 的 double，是隨堂測驗中的延伸題。</p>
<p>output: jkrvivian</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> m[] = &#123; <span class="number">1.7899031678214814931707136432e161</span>,</span><br><span class="line">                   <span class="number">5.43472210425371198594225672155e-322</span> &#125;;</span><br><span class="line">    <span class="built_in">puts</span>((<span class="keyword">char</span> *)m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://jkrvivian.github.io/2018/03/30/my-2-double/" data-id="cknczoq840005ql4w0yp00d4i" data-title="代表我的兩個 Double" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/programming/" rel="tag">programming</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-compiler-lexical-overview" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/02/22/compiler-lexical-overview/" class="article-date">
  <time class="dt-published" datetime="2018-02-21T16:16:51.000Z" itemprop="datePublished">2018-02-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/02/22/compiler-lexical-overview/">噢！我的編譯器 - Lexical Analysis Overview</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>前一篇 <a href="https://jkrvivian.github.io/2018/02/02/compiler-intro-2/">Introduction II</a> 中我們提到編譯器主要的工作就是進行 <strong>分析</strong> 與 <strong>生成</strong>，而又可以再把工作細分為以下，本篇要討論的就是分析的第一步驟： <strong>詞彙分析器 lexical analyzer</strong></p>
<p><strong><span style="color: #000000;">分析 (analysis)</span>:</strong></p>
<ul>
     <li><strong><span style="color: #ff0000;">詞彙分析器 (lexical analyzer)，亦稱 scanner，建立 symbol table</span></strong></li>
     <li>語法分析器 (syntax analyzer)，亦稱 parser</li>
     <li>語意分析器 (semantic analyzer)</li>
     <li>中間碼產生器 (intermediate code generator)</li>
     <li>程式碼最佳化 (code optimizer) <strong>(optional &amp; machine-independent)</strong></li>
</ul>

<h4>Lexical analyzer 做了什麼？</h4>
lexical analyzer 是第一個拿到原始碼的，那它要做什麼呢？

<p>就是<strong>判斷詞性</strong>囉！除了<strong>斷詞</strong>還需要做<strong>分類</strong>，那怎麼樣叫做斷詞呢？</p>
<p>舉個簡單的例子，<code>a = b + 2;</code>，我們可以拆成以下，也就是進行<strong>斷詞</strong>：</p>
<ul>
     <li>a</li>
     <li>=</li>
     <li>b</li>
     <li>+</li>
     <li>2</li>
     <li>;</li>
</ul>
除了會除去空白，還有 Tab 鍵、註解、換行符號等等。另外，也同時根據換行符號得知行號，以做錯誤訊息與程式碼的對應。那<strong>分類</strong>呢？請見以下：
<ul>
     <li>a : <span style="color: #ff6600;">identifier</span></li>
     <li>= :<span style="color: #ff6600;"> assign</span></li>
     <li>b : <span style="color: #ff6600;">identifier</span></li>
     <li>+ :<span style="color: #ff6600;"> plus</span></li>
     <li>2 : <span style="color: #ff6600;">number</span></li>
     <li>; : <span style="color: #ff6600;">semicolon</span></li>
</ul>
而遇到 identifier 時，就會把相關資訊插入 symbol table，所以現在 symbol table 會有 a, b, c 的資訊。

<p>以上就是 lexical analyzer 所做的事情，接下來便會把整理好的資訊與 symbol table 提供給下一個 syntax analyzer 使用。</p>
<h4>token, pattern 和 lexeme</h4>
有了基本概念後，先介紹三個名詞：
<ul>
     <li><strong>token</strong> : 類別及其屬性，以 &lt;token name,  optional attribute&gt; 表示，如 a 就是 &lt;id，pointer to symbol-table entry for a&gt;</li>
     <li><strong>pattern</strong> : 每個類別的格式，如被歸類到 number 這個類別底下的都是數值格式，而 literal 就是被 "" 所環繞的字串</li>
     <li><strong>lexeme</strong> : 類別底下的斷詞，如上述的 id 底下有 a, b, c 三個 lexeme</li>
</ul>
token 跟 lexeme 的解釋很相像，可以用 class 跟 instance 的關係更清楚的說明。token 就像是 class，token name 就是 class 的名稱。而 lexeme 就像是 instance，同 class 可以創造出許多不同的 instances ，同理，同一個 token 可以有很多 lexeme，而這些 lexeme 的不同之處就是 optional attribute，但他們都符合這個 token 的 pattern。當然這種種資訊都會被紀錄在 symbol table 中，以便後面的人接續使用。

<p>看看下表更清楚了：</p>
<table class=" aligncenter" style="width: 678px;">
<tbody>
<tr>
<td style="width: 168px; text-align: center;"><span style="color: #ff6600;"><strong><span style="font-family: book\ antiqua, palatino, serif; font-size: 14pt;">token</span></strong></span></td>
<td style="width: 409.733px; text-align: center;"><span style="color: #ff6600;"><strong><span style="font-family: book\ antiqua, palatino, serif; font-size: 14pt;">pattern</span></strong></span></td>
<td style="width: 344.267px; text-align: center;"><span style="color: #ff6600;"><strong><span style="font-family: book\ antiqua, palatino, serif; font-size: 14pt;">sample lexeme</span></strong></span></td>
</tr>
<tr>
<td style="width: 168px;"><strong>comparison</strong></td>
<td style="width: 409.733px;">&lt; or &gt; or &lt;= or &gt;= or == or !=</td>
<td style="width: 344.267px;">&lt;=, ==</td>
</tr>
<tr>
<td style="width: 168px;"><strong>id</strong></td>
<td style="width: 409.733px;">字母後面跟著字母或數字</td>
<td style="width: 344.267px;">pi, abc, tmp1</td>
</tr>
<tr>
<td style="width: 168px;"><strong>number</strong></td>
<td style="width: 409.733px;">數值常數</td>
<td style="width: 344.267px;">3.14159, 123</td>
</tr>
<tr>
<td style="width: 168px; text-align: left;"><strong>semicolon</strong></td>
<td style="width: 409.733px;">;</td>
<td style="width: 344.267px;">;</td>
</tr>
</tbody>
</table>

<h4 id="Lexical-errors"><a href="#Lexical-errors" class="headerlink" title="Lexical errors"></a>Lexical errors</h4><p>在 lexical 階段除錯是困難的，因為只單純的讀進程式並進行分類。因此，這裡除的錯是 <strong>拼字的錯</strong>，也就是沒有任何一個 token 的 pattern 符合這筆輸入時就是錯誤。那 lexical analyzer 如何處理這個錯誤呢？</p>
<p>龍書裡頭提到幾種修正辦法：</p>
<ol>
<li>刪掉已讀進的字元，直到剩餘字符合某 token 的 pattern</li>
<li>僅刪掉一個字元</li>
<li>插入缺少的字元</li>
<li>替代某個字元</li>
<li>交換某組相鄰字元的順序</li>
</ol>
<p>當然，最單純的方法就是以 <strong>一種</strong> 修正辦法改正目前讀入的字串，以得到符合規範的 lexeme。但最常見的方法其實是依據整份原始碼進行修正，使得全部都是合法的 lexemes，這個實作上也就複雜的多囉！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jkrvivian.github.io/2018/02/22/compiler-lexical-overview/" data-id="cknczoq820004ql4wg1pqgvve" data-title="噢！我的編譯器 - Lexical Analysis Overview" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/compiler/" rel="tag">compiler</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-compiler-intro-2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/02/02/compiler-intro-2/" class="article-date">
  <time class="dt-published" datetime="2018-02-02T15:36:00.000Z" itemprop="datePublished">2018-02-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/02/02/compiler-intro-2/">噢！我的編譯器 - Introduction II</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在上一篇 <a href="https://jkrvivian.github.io/2018/01/30/compiler-intro-1-md/">Introduction to Compiler - I</a> 中簡述了編譯器的工作以及編譯系統的流程，接著我們將更深入的打開 compiler 的盒子，看看它到底是經過了哪些處理完成編譯的！</p>
<h3 id="The-Structure-of-a-Compiler"><a href="#The-Structure-of-a-Compiler" class="headerlink" title="The Structure of a Compiler"></a>The Structure of a Compiler</h3><p>龍書裡面提到，我們可以將編譯器做的事情分為兩階段：</p>
<ol>
<li><strong>分析 (analysis)</strong>: 又稱為 compiler 的 **前端處理 (front-end)**，分析與解構原始碼，並將資訊整理成 <strong>中介表示 (intermediate representation)</strong> 與 <strong>符號表 (symbol table)</strong> 傳給下一階段，當中如果發現任何錯誤就會噴錯誤訊息</li>
<li><strong>生成 (synthesis)</strong>: 又稱為 compiler 的 **後端處理 (back-end)**，根據符號表與中介表示產出目標程式碼</li>
</ol>
<p>套入翻譯的時候大腦快速運轉的流程也是說的通的，總是得對 A 語言的句子進行分析才能夠生成 B 語言的句子啊！例如，這幾學期學得很痛苦的法文 XD</p>
<p>中文的「我起床了」是一句多麼直覺且精簡的表達一個動作，句型就是「主詞 + 動詞 + 語末助詞」，其實翻成英文也十分簡單，”I got up.”，一樣的句型構成，但有了過去式，畢竟起床這事兒已經發生了，反觀法文…….</p>
<p>法文文法書有一課提到「反身」，相當於中文的「我自己」、「你自己」還有英文的 yourself、myself 。但法文不太一樣，有些動詞必須要用反身的句型，例如起床、洗臉、梳頭，因為是「我自己起的床」、「我自己梳的頭」。所以同樣的一句話在法文是 “Je me lève.” 而不是 “Je lève.”，因此看到這句絕對不要翻成「我自己起床」，而是「我起床了」，否則其他人一陣嘲笑就是你的錯誤訊息囉！<br>所以，勢必得對句子進行單字及文法 <strong>分析</strong>，我們才能 <strong>生成</strong> 準確的翻譯囉！學了他國語言總是覺得中文最簡單，但法文特別虐腦倒是真的 QAQ</p>
<p>當然，我們還可以再把編譯器的工作從這兩大點再細分出來：</p>
<ol>
<li><strong><span style="color: #ff6600;">分析 (analysis)</span>:</strong><ul>
<li>詞彙分析器 (lexical analyzer)，亦稱 scanner，建立 symbol table</li>
<li>語法分析器 (syntax analyzer)，亦稱 parser</li>
<li>語意分析器 (semantic analyzer)</li>
<li>中間碼產生器 (intermediate code generator     </li>
<li>程式碼最佳化 (code optimizer) <strong>(optional &amp; machine-independent)</strong></li>
</ul>
</li>
<li><strong><span style="color: #ff6600;">生成 (synthesis)</span></strong>:<ul>
<li>程式碼產生器 (code generator)</li>
<li>機械碼最佳化 (machine-independent code optimizer) <strong>(optional &amp; machine-independent)</strong></li>
</ul>
</li>
</ol>
<p>流程圖如下：</p>
<p>因為 symbol table 在各個步驟都會使用到，因此把它獨立畫出來</p>
<figure>
    <img title="compile 的步驟" src="https://i.imgur.com/6wX3QzL.png" alt="" width="437" height="956" />
    <figcaption style="text-align:center">compile 的步驟</figcaption>
</figure>

<p>先有個概觀，接下來我們就要把焦點移到各個步驟囉！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jkrvivian.github.io/2018/02/02/compiler-intro-2/" data-id="cknczoq7x0001ql4w3lireuxy" data-title="噢！我的編譯器 - Introduction II" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/compiler/" rel="tag">compiler</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-compiler-intro-1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/01/30/compiler-intro-1/" class="article-date">
  <time class="dt-published" datetime="2018-01-29T16:46:17.000Z" itemprop="datePublished">2018-01-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/01/30/compiler-intro-1/">噢！我的編譯器 - Introduction I</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>趁著這個寒假再趕緊複習近一年前選修過的 compiler，除了釐清整個架構流程與觀念，也期望能有對應的實做練習。其實只是下學期要當助教，得把這些東西撿回來 XD</p>
<p>之後的整理皆基於:</p>
<ul>
<li>龍書 (Compilers principles, techniques, and tools)</li>
<li>Stanford <a target="_blank" rel="noopener" href="http://web.stanford.edu/class/cs143/">CS143</a> 的開放式課程</li>
<li>自己的想法</li>
</ul>
<p>希望能夠闡述的更輕鬆且容易理解，大致上就這樣，我們開始吧！</p>
<h3 id="Introduction-I"><a href="#Introduction-I" class="headerlink" title="Introduction I"></a>Introduction I</h3><p>其實編譯器的角色套用在現實生活中能夠特別清楚的解釋他的角色及功用 – <strong>翻譯人員</strong>。不論是即時口譯還是各節目或動畫的專業字幕組都是，反正只要始能把 A 語言流暢的翻成 B 語言的都算。但翻譯的工作並不是那麼簡單，需要理解某語言的生字、語法才能夠進行，當然更專業的人員還能夠使用精簡的句子傳達意境，甚至即使他文法錯了，翻譯大大也能理解並<strong>精準的</strong>譯出正確的意思。總之，翻譯其實不僅僅是「翻譯」，還要再經過「編輯」，這也就是 “compile” 「編譯」的意思。</p>
<h4 id="編譯器-Compiler"><a href="#編譯器-Compiler" class="headerlink" title="編譯器 Compiler"></a>編譯器 Compiler</h4><p>了解之後，我們再把視角拉回 compiler 上，<strong>compiler 就是程式語言間的翻譯員</strong>，不同的 compiler 會編譯成不同的語言，有可能是轉成機器語言(machine code)、byte code，甚至是另一種語言，如圖:</p>
<figure>
    <img title="編譯器 compiler" src="https://i.imgur.com/VoFfTlC.png" alt="" width="403" height="79" />
    <figcaption style="text-align:center">編譯器 compiler</figcaption>
</figure>


<p>產生出來的 target program 就能夠執行囉！所以程式的編譯到執行是這樣的：</p>
<figure>
    <img title="從原始碼到編譯執行" src="https://i.imgur.com/mfg6GXG.png" alt="" width="403" height="315" />
    <figcaption style="text-align:center">從原始碼到編譯執行</figcaption>
</figure>


<h4 id="直譯器-Interpreter"><a href="#直譯器-Interpreter" class="headerlink" title="直譯器 Interpreter"></a>直譯器 Interpreter</h4><p>還有另一種語言處理的工具：<strong>直譯器 (interpreter)<strong>。相較於上圖，compiler 是編譯程式碼後產出可執行的程式碼，由使用者輸入 input 後，再得到 output。而直譯器是 source code 與 input 一次給，</strong>直接編譯並執行</strong>，產出 output ，而使用直譯器的語言有大名鼎鼎的 python。而的架構圖如下：</p>
<figure>
    <img title="直譯器 Interpreter" src="https://i.imgur.com/SUm3jVH.png" alt="" width="222" height="293" />
    <figcaption style="text-align:center">直譯器 Interpreter</figcaption>
</figure>

<p>而 compiler 與 interpreter 還有速度上的差異，compiler 產生的 target program 執行的比 interpreter 快。但 interpreter 的偵錯又比較好了，畢竟是一行行程式碼檢查與執行下來。</p>
<h4 id="compilation-interpretation"><a href="#compilation-interpretation" class="headerlink" title="compilation + interpretation"></a>compilation + interpretation</h4><p>再來，勢必要提及赫赫有名的 Java，為什麼呢？Java 是一個結合 compilation 和 interpretation 的程式語言，這是什麼意思？就是 Java 會先編譯成一種編碼稱為 <strong>byte code</strong>，接著再直譯成機器碼。這個的好處是，Java 經過一次編譯，就可以透過<strong>虛擬機</strong> (<strong>virtual machine</strong>) 在不同的機器上直譯執行。沿用翻譯員的例子，byte code 就有像是目前的國際語言<strong>英文</strong>，只要 A 語言翻譯成英文，到 B 國人人都能直接把英語翻譯成自己的語言(當然前提是大家都會英文)，因此到任何國家都能夠溝通了！整個架構可以繪製成下圖：</p>
<figure>
    <img title="hybrid compiler" src="https://i.imgur.com/6RnzT7T.png" alt="" width="260" height="507" />
    <figcaption style="text-align:center">hybrid compiler</figcaption>
</figure>


<h4 id="編譯系統-Compilation-System"><a href="#編譯系統-Compilation-System" class="headerlink" title="編譯系統 Compilation System"></a>編譯系統 Compilation System</h4><p>了解編譯器的角色與功能後，我們可以接著探討編譯系統是由哪些角色所組成的。</p>
<ol>
<li><strong>預處理 (preprocessor)</strong>: 負責在引用 header file、libraries 的檔案插入完整的程式碼，以 C 為例就是根據 <code>#</code> 開頭的指令，e.g., <code>#include stdio.h</code>，直接插入 stdio.h 的內容。</li>
<li><strong>編譯器 (compiler)</strong>: 把重新編輯好的檔案再轉交給 compiler 編譯成<strong>組合語言 (assembly language)<strong>，簡稱</strong>組語</strong>。而使用組語的最重要的原因是不同的高階程式語言都可以組譯成相同的組語，也比機器碼還好 debug。 p.s. 組語是因硬體架構而異。</li>
<li><strong>組譯器 (assembler)</strong>: 將組語轉譯為**機械碼 (machine code)**，並打包成重新定位的 **目標檔 (object file)**。</li>
<li><strong>連結器 (linker)</strong>: 負責合併所有 object files 並產生可執行的檔案，可以被加載到記憶體執行。</li>
</ol>
<p>我們再把流程畫成下圖：</p>
<figure>
    <img title="編譯系統" src="https://i.imgur.com/N8Wu8vv.png" alt="" width="292" height="702" />
    <figcaption style="text-align:center">編譯系統</figcaption>
</figure>

<p>到目前為止，我們對編譯器以及編譯系統就有初步的了解了！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jkrvivian.github.io/2018/01/30/compiler-intro-1/" data-id="cknczoq7r0000ql4wcqxigr92" data-title="噢！我的編譯器 - Introduction I" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/compiler/" rel="tag">compiler</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-tokio-hotel-md" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/01/27/tokio-hotel-md/" class="article-date">
  <time class="dt-published" datetime="2018-01-27T07:17:42.000Z" itemprop="datePublished">2018-01-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/01/27/tokio-hotel-md/">德國天團 Tokio Hotel</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="最喜歡的樂團"><a href="#最喜歡的樂團" class="headerlink" title="最喜歡的樂團"></a>最喜歡的樂團</h2><p>Tokio Hotel 是一個由四個德國男孩所組成的樂團，小小年紀出道，在 2005 年以 <a target="_blank" rel="noopener" href="https://youtu.be/9BuaN2Pz0Ns">Durch den monsun</a> 走紅，紅遍歐洲各國，甚至颳起一陣學習德文的風潮。四位成員分別有 Bill Kaulitz (主唱)、Tom Kaulitz (吉他手)、Georg Listing (貝斯手)、Gustav Schäfer (鼓手)。我想最令人驚豔的是每張專輯曲目，幾乎是由 Bill 及 Tom 作詞作曲完成！如此年輕的樂團獲獎無數，最佳樂團、最佳專輯等等，並逐步打入歐美甚至亞洲市場。</p>
<p>我國二的時候 Humanoid 中的 <a target="_blank" rel="noopener" href="https://youtu.be/WhIlqBqRtuw">Automatic</a> 登上了 Billboard 排行榜，也正是從那時開始認識 Tokio Hotel，並持續關注到現在，不知不覺八、九年就過去了！回想國高中時期，這個樂團影響我許多，學了一點德文，開始彈吉他都是因他們起，在考試壓力下聽著 <a target="_blank" rel="noopener" href="https://youtu.be/waXx9k7_2_0">Scream</a> 吼，難過時 <a target="_blank" rel="noopener" href="https://youtu.be/LujKFKcoHNg">Hilf mir fliegen</a> 就彷彿他們陪在我身邊，看著 Unplugged 版 <a target="_blank" rel="noopener" href="https://youtu.be/JWPDPKXk-bs">Reden</a> 的影片那燦爛的微笑，心情就漸漸跟著愉快起來。當然也不得不提這四位的同人小說也讓我走上一條不歸路。</p>
<p>直到近兩張專輯，King of Suburbia 和 Dream Machine 引起了廣大討論，曲風有了大改變，不再是以前那麼單純的吉他、貝斯與鼓，而加了許多電音元素，就連 Bill 的唱法都有了不同。因此便有 Tokio Hotel 不再是以前的 Tokio Hotel 等負面評論出現。我想正是因為這個轉變，Dream Machine 才沒有代理商代理在台灣販售….。</p>
<p>我們跟著 Tokio Hotel 成長，誰不是成長後對事物有不同的看法呢？曲，加了許多新的元素進去，對自己是突破，也更帶著聽眾認識了不一樣的音樂世界；詞，是他們的心情，對社會的觀察。在 Dream Machine 的採訪中，成員們很驕傲的說終於做了一張自己想做的專輯，且詞與曲一樣由 Bill 和 Tom 親寫親編。Tokio Hotel 確實變了，成熟了，對音樂有更多新的想法與見解，但不變的是他們對音樂的熱忱與要求。</p>
<p>我依然喜歡他們的新作，更喜歡他們衷於自己，期待未來的作品中還能看到 Tokio Hotel 的不同樣貌。</p>
<p><img src="http://www.dw.com/image/37994008_304.jpg" alt="Dream machine"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jkrvivian.github.io/2018/01/27/tokio-hotel-md/" data-id="cknczoq860008ql4w71dl56h9" data-title="德國天團 Tokio Hotel" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/music/" rel="tag">music</a></li></ul>

    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/compiler/" rel="tag">compiler</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/music/" rel="tag">music</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/programming/" rel="tag">programming</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/compiler/" style="font-size: 20px;">compiler</a> <a href="/tags/music/" style="font-size: 10px;">music</a> <a href="/tags/programming/" style="font-size: 10px;">programming</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/04/03/compiler-lexical-detail/">噢！我的編譯器 – Lexical Analysis Detail</a>
          </li>
        
          <li>
            <a href="/2018/03/30/my-2-double/">代表我的兩個 Double</a>
          </li>
        
          <li>
            <a href="/2018/02/22/compiler-lexical-overview/">噢！我的編譯器 - Lexical Analysis Overview</a>
          </li>
        
          <li>
            <a href="/2018/02/02/compiler-intro-2/">噢！我的編譯器 - Introduction II</a>
          </li>
        
          <li>
            <a href="/2018/01/30/compiler-intro-1/">噢！我的編譯器 - Introduction I</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 Vivian Lin<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>